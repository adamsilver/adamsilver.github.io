<!DOCTYPE HTML>
<html dir="ltr" lang="en">
	<head>
	    <title>The disadvantages of Javascript polyfills | Adam Silver | UX design, Front-end Engineering and Strategy | London, UK.</title>
	    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="viewport" content="initial-scale=1.0">
<meta name="Author" content="Adam Silver">

<link rel="apple-touch-icon" sizes="57x57" href="http://adamsilver.io/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="http://adamsilver.io/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="http://adamsilver.io/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="http://adamsilver.io/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="http://adamsilver.io/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="http://adamsilver.io/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="http://adamsilver.io/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="http://adamsilver.io/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://adamsilver.io/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="http://adamsilver.io/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="http://adamsilver.io/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="http://adamsilver.io/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="http://adamsilver.io/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="http://adamsilver.io/manifest.json">
<link rel="mask-icon" href="http://adamsilver.io/safari-pinned-tab.svg" color="#001f3f">
<meta name="msapplication-TileColor" content="#001F3F">
<meta name="msapplication-TileImage" content="http://adamsilver.io/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">

<meta property="og:locale" content="en_GB">
<meta property="og:type" content="website">


	<meta content="The disadvantages of Javascript polyfills" property="og:title">



	<meta property="og:description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<meta property="og:url" content="http://adamsilver.io/articles/the-disadvantages-of-javascript-polyfills/">
<meta property="og:site_name" content="Adamsilver.io">
<meta property="og:image" content="http://adamsilver.io/assets/img/card.png">
<meta property="og:image:width" content="181">
<meta property="og:image:height" content="181">

<meta name="twitter:card" content="summary">


	<meta name="twitter:description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<meta name="twitter:title" content="The disadvantages of Javascript polyfills -  Adam Silver | UX design, Front-end Engineering and Strategy | London, UK.">


	<meta content="The disadvantages of Javascript polyfills" name="twitter:title">


<meta name="twitter:site" content="@adambsilver">
<meta name="twitter:creator" content="@adambsilver">
<meta property="twitter:image" content="http://adamsilver.io/assets/img/card.png">


	<meta itemprop="description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<link rel="stylesheet" href="/assets/css/main.min.fc7935d3.css" media="all">

<!--[if IE 8]>
<link rel="stylesheet" href="/assets/css/ie8.min.d41d8cd9.css" media="all">
<![endif]-->

<!--[if IE 7]>
<link rel="stylesheet" href="/assets/css/ie7.min.d41d8cd9.css" media="all">
<![endif]-->


<!--[if IE 6]>
<link rel="stylesheet" href="/assets/css/ie6.min.2d22a25b.css" media="all">
<![endif]-->


<link rel="canonical" href="http://adamsilver.io/articles/the-disadvantages-of-javascript-polyfills/">
<link rel="author" href="https://plus.google.com/u/0/+AdamSilver1">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47311666-1', 'auto');
  ga('send', 'pageview');

</script>

	</head>
	<body>
	    <nav class="nav">
	<ul>
		<li><a class="" href="/">Home</a></li>
		<li><a class="nav-active" href="/articles/">Articles</a></li>
		<li><a class="" href="/about/">About</a></li>
		<li><a class="" href="/signup/">Newsletter</a></li>
	</ul>
</nav>
	    <main class="mainContent">
			<h1>The disadvantages of Javascript polyfills</h1>
	        <p>A polyfill, also known as a shim, is a user-defined implementation of an API that some browsers provide natively, normalising browser differences.</p>

<p>As a huge proponent of the <a href="/articles/developing-templates-using-an-outside-in-approach">outside-in approach to development</a>, I see the lure of trying to develop websites as if all browsers are the same.</p>

<p>However, this article discusses the problems we face when attempting to tame browsers in this way, which ultimately results in unreliable Javascript, unreliable web pages and of course, unhappy users.</p>

<h2 id="augmenting-host-objects-is-a-bad-idea">1. Augmenting host objects is a bad idea</h2>

<p>Polyfills must augment host and native objects. Experts such as Richard Cornford, David Mark, Thomas Lahn and Kangax have all told us this is a bad idea. The latter of which published two dedicated articles on the matter:</p>

<ul>
  <li><a href="http://perfectionkills.com/whats-wrong-with-extending-the-dom/">What’s wrong with extending the DOM?</a>; and</li>
  <li><a href="http://perfectionkills.com/extending-native-builtins/">Extending native built-ins</a>.</li>
</ul>

<p>Here’s a choice snippet if you don’t have time to read the articles:</p>

<blockquote>
  <p>“DOM extension seemed so temptingly useful […]. But what hides behind this seemingly innocuous practice is a huge load of trouble. […] the downsides of this approach far outweigh any benefits.”</p>
</blockquote>

<h2 id="feature-detection-is-not-enough">2. Feature detection is not enough</h2>

<p>As Peter Michaux shows us in <a href="http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting">Feature Detection: State of the art browser scripting</a>, the mere presence of an API is not necessarily enough to determine reliable usage. This is where feature <em>testing</em> comes in.</p>

<p>Polyfills tend to just detect the presence of an API; they do not iron out the bugs or inconsistencies found in different browsers. Even if they did, they would have to override the original, whereby the override may contain a reference to the original. This is a dangerous and unnecessary way to go. This is why we should use facades as we’ll see later.</p>

<h2 id="we-should-decouple-browser-and-application-logic">3. We should decouple browser and application logic</h2>

<p>As Nicholas Zakas says in <a href="https://www.youtube.com/watch?v=vXjVFPosQHw">Scalable JavaScript Application Architecture</a>, it is important to decouple application and browser logic. He states:</p>

<blockquote>
  <p>“Application logic should be written one way for all browsers in order to keep the code maintainable. If you’re using native APIs in your application logic, you can’t help but know what browser is being used because you need to account for browser differences. That means your application logic will always need to be updated as new browsers and new browser versions are released. <strong>That’s a recipe for disaster</strong>”.</p>
</blockquote>

<h2 id="you-may-not-need-the-full-api">4. You may not need the full API</h2>

<p>You may not need the full API to solve your problem. You may not even be <em>able</em> to implement a polyfill because there’s just no way to do it. This is why context is important.</p>

<p>We should first understand the exact problem we’re trying to solve. And only then solve that problem. We shouldn’t do more than solve that problem.</p>

<p>With polyfills it’s all or nothing. We rarely need <em>all</em> of an API and the solution is rarely lean.</p>

<h2 id="polyfills-suffer-from-caveats">5. Polyfills suffer from caveats</h2>

<p>It doesn’t take much effort to find examples of problematic polyfills. Take the <a href="https://github.com/es-shims/es5-shim">ES5 Shim</a> documentation. In describing the <code>Object.create</code> polyfill it states:</p>

<blockquote>
  <p>“For the case of simply “begetting” an object that inherits prototypically from another, this <strong>should</strong> work fine across legacy engines.”</p>
</blockquote>

<p>The word “should” doesn’t instill confidence does it? Personally, I like to build on top of reliable foundations. You’re only as reliable as your lowest level function(s). So in the case of polyfills that would be, not very. It continues:</p>

<blockquote>
  <p>“The second argument is passed to Object.defineProperties which will <strong>probably fail either silently or with extreme prejudice</strong>.”</p>
</blockquote>

<p>Do you want your team want to rely on code like this? Of course not. Any code you write atop of this is just polishing a turd, as the saying goes.</p>

<h2 id="what-should-we-do-instead">What should we do instead?</h2>

<p>A facade, a form of wrapper, is a design pattern that simplifies an interface to something more complex. This allows you to completely abstract away the differing browser implementations and bugs. And with the added bonus of being able to simplify the method signature.</p>

<p>Inside the facade there is nothing to stop you using portions of an API, and feature testing various implementations and acting accordingly, much like Peter Michaux shows us in his other brilliant article <a href="http://peter.michaux.ca/articles/cross-browser-widgets">Cross browser Widgets</a>.</p>

<p>Cloning an object is pertinent to this article because <code>Object.create</code> is a useful API to solve this problem. If you just wanted to support “modern” browsers i.e ones that provide <code>Object.create</code>, then an implementation might be as follows:</p>

<pre><code>var lib = {};
if(Object.create) {
  lib.cloneObject = function(obj) {
    return Object.create(obj);
  };
}
</code></pre>

<p>Note there is only one argument. This facade uses a smaller part of an API, exposing a simpler method signature creating a lean solution to our problem in the process. What about browsers lacking <code>Object.create</code>?</p>

<p>If you want to degrade gracefully, you don’t have to do anything. If you want to support other browsers you can add a second fork as follows:</p>

<pre><code>// Code credited to David Mark. Thanks.
var lib = {};
if(Object.create) {
  lib.cloneObject = function(obj) {
    return Object.create(obj);
  };
} else {
  lib.cloneObject = (function() {
    var Fn = function() {};
      return function(obj) {
        Fn.prototype = obj;
        return new Fn();
    };
  })();
}
</code></pre>

<p>The context of the problem changed. It got a little harder — but the implementation is still lean and the method signature still works well. But, we didn’t need to worry about recreating <code>Object.create</code> in its entirety.</p>

<p>But, what if you did need the full API? We would need two simple edits: change the name of the function to something more appropriate and expand the method signature to allow for property descriptors:</p>

<pre><code>var lib = {};
if(Object.create) {
  lib.createObject = function(obj, props) {
    return Object.create(obj, props);
  };
}
</code></pre>

<p>What about browsers lacking <code>Object.create</code>? Same as before. Either degrade gracefully or add another fork. This is the very essence of Progressive Enhancement.</p>

<h2 id="summary">Summary</h2>

<p>At first polyfills seem like a good idea. But now that we have explored the intricacies of this technique, it’s clear that at best, polyfills are harder to implement and cause application and browser logic to be tightly coupled, which is costly.</p>

<p>At their worst they come with highly problematic caveats that cause pain for the developer. But even worse than that, they result in unreliable software and unhappy users. Instead, we should use facades, which allows us to build reliable, lean and Progressively Enhanced websites.</p>

<!--

* ADDED IMPLEMENTATION Just because an API is implemented in a browser doesn't mean it's trustworthy. Sometimes, the spec is simply misunderstood and implemented differently across browser vendors. Adding a polyfill to the mix just adds complexity in the form of another user-defined implementation.

* CONSISTENCY Then there is the question of consistency. Do you want to use some polyfills and some facades. Probably not. Just use a consistent abstraction, a facade.

-->

	    </main>
		<div class="signUpHero  signUpHero-isArticle ">
	<h2 class="signUpHero-heading">Join my newsletter</h2>
	<p class="signUpHero-description">If you want to read about designing inclusive, simple and human experiences on the web, you'll probably love my newsletter.</p>
	<form action="//adamsilver.us9.list-manage.com/subscribe/post?u=b8fb04f39bf86109693e00ba5&amp;id=441c045a36" method="post">
		<input type="hidden" name="b_b8fb04f39bf86109693e00ba5_441c045a36" value="">
		<input type="hidden" name="SITE" value="http://adamsilver.io">
		<input type="hidden" name="LOCATION" value="/articles/the-disadvantages-of-javascript-polyfills/">
		<label for="mce-EMAIL" class="signUpHero-label">Your email address</label>
		<input type="email" name="EMAIL" id="mce-EMAIL" class="signUpHero-email" required>
		<input class="signUpHero-button" type="submit" value="Sign up" name="subscribe">
	</form>
</div>
		<footer class="footer">
	<p>You can find me on <a href="http://www.twitter.com/adambsilver/">Twitter</a>, <a href="http://www.github.com/adamsilver/">Github</a>, <a href="http://uk.linkedin.com/in/adambsilver/">Linkedin</a> and <a href="http://medium.com/@adambsilver">Medium</a>.
	</p>
</footer>
	</body>
</html>