<!DOCTYPE HTML>
<html dir="ltr" lang="en">
	<head>
	    
	
		<title>The disadvantages of Javascript polyfills by Adam Silver</title>
	


<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="viewport" content="initial-scale=1.0">
<meta name="Author" content="Adam Silver">

<link rel="apple-touch-icon" sizes="57x57" href="http://adamsilver.io/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="http://adamsilver.io/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="http://adamsilver.io/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="http://adamsilver.io/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="http://adamsilver.io/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="http://adamsilver.io/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="http://adamsilver.io/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="http://adamsilver.io/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://adamsilver.io/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="http://adamsilver.io/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="http://adamsilver.io/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="http://adamsilver.io/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="http://adamsilver.io/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="http://adamsilver.io/manifest.json">
<link rel="mask-icon" href="http://adamsilver.io/safari-pinned-tab.svg" color="#001f3f">
<meta name="msapplication-TileColor" content="#001F3F">
<meta name="msapplication-TileImage" content="http://adamsilver.io/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">

<meta property="og:locale" content="en_GB">
<meta property="og:type" content="website">


	
		<meta content="The disadvantages of Javascript polyfills by Adam Silver" property="og:title">
	



	<meta property="og:description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<meta property="og:url" content="http://adamsilver.io/articles/the-disadvantages-of-javascript-polyfills/">
<meta property="og:site_name" content="Adamsilver.io">
<meta property="og:image" content="http://adamsilver.io/assets/img/card.png">
<meta property="og:image:width" content="181">
<meta property="og:image:height" content="181">

<meta name="twitter:card" content="summary">


	<meta name="twitter:description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<meta name="twitter:title" content="The disadvantages of Javascript polyfills -  Adam Silver: Designing simple, human and inclusive websites.">


	<meta content="The disadvantages of Javascript polyfills" name="twitter:title">


<meta name="twitter:site" content="@adambsilver">
<meta name="twitter:creator" content="@adambsilver">
<meta property="twitter:image" content="http://adamsilver.io/assets/img/card.png">


	<meta itemprop="description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<link rel="stylesheet" href="/assets/css/main.min.8e45add8.css" media="all">

<!--[if IE 8]>
<link rel="stylesheet" href="/assets/css/ie8.min.d41d8cd9.css" media="all">
<![endif]-->

<!--[if IE 7]>
<link rel="stylesheet" href="/assets/css/ie7.min.d41d8cd9.css" media="all">
<![endif]-->


<!--[if IE 6]>
<link rel="stylesheet" href="/assets/css/ie6.min.2d22a25b.css" media="all">
<![endif]-->


<link rel="canonical" href="http://adamsilver.io/articles/the-disadvantages-of-javascript-polyfills/">
<link rel="author" href="https://plus.google.com/u/0/+AdamSilver1">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47311666-1', 'auto');
  ga('send', 'pageview');

</script>

	</head>
	<body>
	    <nav class="nav">
	<ul>
		<li><a class="" href="/">Home</a></li>
		<li><a class="nav-active" href="/articles/">Articles</a></li>
		<li><a class="" href="/about/">About</a></li>
		<li><a class="" href="/signup/">Newsletter</a></li>
	</ul>
</nav>
	    <main class="mainContent">
			<h1 class="article-heading">The disadvantages of Javascript polyfills</h1>
			<!-- <div class="meta">
	<time class="meta-date" date-time="2015-06-22">22 June 2015</time> <span class="meta-divider">&#183;</span>
	<span class="meta-readingTime" title="Estimated read time">
	  

	  
	    4 minute read
	  
	</span>
</div> -->
	        <p>A polyfill, also known as a shim, is a user-defined implementation of an API that some browsers provide natively, normalising browser differences.</p>

<p>As a proponent of <a href="/articles/developing-templates-using-an-outside-in-approach">outside-in development</a>, I see the lure of trying to develop websites as if all browsers are the same. The problem is that <a href="/articles/browsers-are-different-but-so-what/">browsers are not the same</a>. And tackling the “problem” with a polyfill is problematic. Here’s why:</p>

<h2 id="they-augmenting-host-objects">1. They augmenting host objects</h2>

<p>Polyfills augment host and native objects. Experts such as Richard Cornford, David Mark, Thomas Lahn and Kangax have told us this is a bad idea. The latter of which published two articles on the matter: <a href="http://perfectionkills.com/whats-wrong-with-extending-the-dom/">What’s wrong with extending the DOM?</a> and <a href="http://perfectionkills.com/extending-native-builtins/">Extending native built-ins</a>.</p>

<p>Here’s a choice snippet if you don’t have time to read the articles:</p>

<blockquote>
  <p>“DOM extension seemed so temptingly useful […]. But what hides behind this seemingly innocuous practice is a huge load of trouble. […] the downsides of this approach far outweigh any benefits.”</p>
</blockquote>

<h2 id="feature-detection-is-not-enough">2. Feature detection is not enough</h2>

<p>As Peter Michaux shows us in <a href="http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting">Feature Detection: State of the art browser scripting</a>, the mere presence of an API is not always enough to determine its reliablity. This is where feature <em>testing</em> comes in.</p>

<p>Polyfills tend to just detect the presence of an API. They do not iron out the bugs or inconsistencies found in different browsers. Even if they did, they would have to override the original, whereby the override may contain a reference to it. This is dangerous and unnecessary. Instead, we should use facades as we’ll discuss shortly.</p>

<h2 id="they-intertwine-browser-and-application-logic-together">3. They intertwine browser and application logic together</h2>

<p>As Nicholas Zakas says in <a href="https://www.youtube.com/watch?v=vXjVFPosQHw">Scalable JavaScript Application Architecture</a>, it is important to decouple application and browser logic. He states:</p>

<blockquote>
  <p>“Application logic should be written one way for all browsers in order to keep the code maintainable. If you’re using native APIs in your application logic, you can’t help but know what browser is being used because you need to account for browser differences. That means your application logic will always need to be updated as new browsers and new browser versions are released. <strong>That’s a recipe for disaster</strong>”.</p>
</blockquote>

<h2 id="we-rarely-need-need-the-full-api">4. We rarely need need the full API</h2>

<p>We may not need the full API to solve the problem. We may not even be <em>able</em> to implement a polyfill because there’s just no way to do it. This is why context is important.</p>

<p>We should first look to understand the problem precisely. And then solve <em>that</em> problem only. We rarely need <em>all</em> of an API, which is something we’ll discuss shortly. With polyfills it’s all or nothing.</p>

<h2 id="they-come-with-caveats">5. They come with caveats</h2>

<p>It takes little effort to find problematic polyfills. Take the <a href="https://github.com/es-shims/es5-shim">ES5 Shim</a> documentation. In describing the <code>Object.create</code> polyfill it states:</p>

<blockquote>
  <p>“For the case of simply “begetting” an object that inherits prototypically from another, this <strong>should</strong> work fine across legacy engines.”</p>
</blockquote>

<p>Emphasis mine. The word <em>should</em> doesn’t instill confidence. We should, of course, build atop of reliable foundations—we are only as good as our lowest level functions. It continues:</p>

<blockquote>
  <p>“The second argument is passed to Object.defineProperties which will <strong>probably fail either silently or with extreme prejudice</strong>.”</p>
</blockquote>

<p>Emphasis mine. We shouldn’t expect our team to rely on code like this, much less our users. Any code we write around this is just <em>polishing a turd</em>, as the saying goes.</p>

<h2 id="what-should-we-do-instead">What should we do instead?</h2>

<p>A facade or wrapper, is a design pattern that simplifies an interface to something more complex. This allows us to abstract away the differing browser implementations and bugs. And with the added bonus of being able to simplify the method signature.</p>

<p>Inside the facade there is nothing to stop us using bits of an API, and feature testing various implementations and acting accordingly, much like Peter Michaux shows us in his other article <a href="http://peter.michaux.ca/articles/cross-browser-widgets">Cross browser Widgets</a>.</p>

<p>Cloning an object is pertinent to this article because <code>Object.create</code> solves this problem. If we want to support <em>modern</em> browsers only i.e ones that provide <code>Object.create</code>, then an implementation might be as follows:</p>

<pre><code>var lib = {};
if(Object.create) {
  lib.cloneObject = function(obj) {
    return Object.create(obj);
  };
}
</code></pre>

<p>As this implementation only uses a small part of the entire API, the exposed method signature has just one argument, solving the precise problem and no more. But what about browsers lacking <code>Object.create</code>?</p>

<p>If we want to degrade gracefully, we don’t have to do anything. If we want to support other browsers add a second fork as follows:</p>

<pre><code>// Code credited to David Mark. Thanks.
var lib = {};
if(Object.create) {
  lib.cloneObject = function(obj) {
    return Object.create(obj);
  };
} else {
  lib.cloneObject = (function() {
    var Fn = function() {};
      return function(obj) {
        Fn.prototype = obj;
        return new Fn();
    };
  })();
}
</code></pre>

<p>The context of the problem changed. It got a little harder — but the implementation is still lean and the method signature still works well. But, we didn’t need to worry about recreating <code>Object.create</code> in its entirety.</p>

<p>But, what if we did need the full API? We would need two simple changes: change the name of the function to something more appropriate and expand the method signature to allow for property descriptors:</p>

<pre><code>var lib = {};
if(Object.create) {
  lib.createObject = function(obj, props) {
    return Object.create(obj, props);
  };
}
</code></pre>

<p>What about browsers lacking <code>Object.create</code>? Same as before. Either degrade gracefully or add another fork. This is the very essence of Progressive Enhancement.</p>

<h2 id="summary">Summary</h2>

<p>Having discussed polyfills in detail, it’s clear that, at best, they are hard to implement and they intertwine browser and application logic. This intertwining is complicated and costly.</p>

<p>At their worst, polyfills have caveats and gaps that cause pain for the developer and broken experiences for users.</p>

<p>Instead, we should use facades, which enable us to build reliable, progressively enhanced, and in inclusive experiences. This, of course, results in happy users.</p>

<!--

* ADDED IMPLEMENTATION Just because an API is implemented in a browser doesn't mean it's trustworthy. Sometimes, the spec is simply misunderstood and implemented differently across browser vendors. Adding a polyfill to the mix just adds complexity in the form of another user-defined implementation.

* CONSISTENCY Then there is the question of consistency. Do you want to use some polyfills and some facades. Probably not. Just use a consistent abstraction, a facade.

-->

	    </main>
		<div class="signUpHero  signUpHero-isArticle ">
	<h2 class="signUpHero-heading">Join my newsletter</h2>
	<p class="signUpHero-description">If you want to read about designing inclusive, simple and human experiences on the web, you'll probably love my newsletter.</p>
	<form action="//adamsilver.us9.list-manage.com/subscribe/post?u=b8fb04f39bf86109693e00ba5&amp;id=441c045a36" method="post">
		<input type="hidden" name="b_b8fb04f39bf86109693e00ba5_441c045a36" value="">
		<input type="hidden" name="SITE" value="http://adamsilver.io">
		<input type="hidden" name="LOCATION" value="/articles/the-disadvantages-of-javascript-polyfills/">
		<label for="mce-EMAIL" class="signUpHero-label">Your email address</label>
		<input type="email" name="EMAIL" id="mce-EMAIL" class="signUpHero-email" required>
		<input class="signUpHero-button" type="submit" value="Sign up" name="subscribe">
	</form>
</div>
		<footer class="footer">
	<p>You can find me on <a href="http://www.twitter.com/adambsilver/">Twitter</a>, <a href="http://www.github.com/adamsilver/">Github</a>, <a href="http://uk.linkedin.com/in/adambsilver/">Linkedin</a> and <a href="http://medium.com/@adambsilver">Medium</a>.
	</p>
</footer>
	</body>
</html>