<!DOCTYPE HTML>
<html dir="ltr" lang="en">
	<head>
	    
	
		<title>The disadvantages of Javascript polyfills by Adam Silver</title>
	


<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="viewport" content="initial-scale=1.0">
<meta name="Author" content="Adam Silver">

<link rel="apple-touch-icon" sizes="57x57" href="https://adamsilver.io/apple-touch-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="https://adamsilver.io/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="https://adamsilver.io/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="https://adamsilver.io/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="https://adamsilver.io/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="https://adamsilver.io/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="https://adamsilver.io/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="https://adamsilver.io/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://adamsilver.io/apple-touch-icon-180x180.png">
<link rel="icon" type="image/png" href="https://adamsilver.io/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://adamsilver.io/android-chrome-192x192.png" sizes="192x192">
<link rel="icon" type="image/png" href="https://adamsilver.io/favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="https://adamsilver.io/favicon-16x16.png" sizes="16x16">
<link rel="manifest" href="https://adamsilver.io/manifest.json">
<link rel="mask-icon" href="https://adamsilver.io/safari-pinned-tab.svg" color="#001f3f">
<meta name="msapplication-TileColor" content="#001F3F">
<meta name="msapplication-TileImage" content="https://adamsilver.io/mstile-144x144.png">
<meta name="theme-color" content="#ffffff">

<meta property="og:locale" content="en_GB">
<meta property="og:type" content="website">


	
		<meta content="The disadvantages of Javascript polyfills by Adam Silver" property="og:title">
	



	<meta property="og:description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<meta property="og:url" content="https://adamsilver.io/articles/the-disadvantages-of-javascript-polyfills/">
<meta property="og:site_name" content="Adamsilver.io">
<meta property="og:image" content="https://adamsilver.io/assets/img/card.png">
<meta property="og:image:width" content="181">
<meta property="og:image:height" content="181">

<meta name="twitter:card" content="summary">


	<meta name="twitter:description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<meta name="twitter:title" content="The disadvantages of Javascript polyfills -  Adam Silver: interaction designer and interface developer from London, UK">


	<meta content="The disadvantages of Javascript polyfills" name="twitter:title">


<meta name="twitter:site" content="@adambsilver">
<meta name="twitter:creator" content="@adambsilver">
<meta property="twitter:image" content="https://adamsilver.io/assets/img/card.png">


	<meta itemprop="description" content="Javascript polyfills are ever-present in the front end industry, but they are very problematic and unnecessary.">


<link rel="stylesheet" href="/assets/css/main.min.826a2ce8.css" media="all">

<!--[if IE 8]>
<link rel="stylesheet" href="/assets/css/ie8.min.d41d8cd9.css" media="all">
<![endif]-->

<!--[if IE 7]>
<link rel="stylesheet" href="/assets/css/ie7.min.d41d8cd9.css" media="all">
<![endif]-->


<!--[if IE 6]>
<link rel="stylesheet" href="/assets/css/ie6.min.2d22a25b.css" media="all">
<![endif]-->


<link rel="canonical" href="https://adamsilver.io/articles/the-disadvantages-of-javascript-polyfills/">
<link rel="author" href="https://plus.google.com/u/0/+AdamSilver1">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47311666-1', 'auto');
  ga('send', 'pageview');

</script>

	</head>
	<body>
	  <!-- <header role="banner">
	<a href="/"><img src="/assets/img/logo2.png" alt="Home" width="100"></a>
</header> -->
	<nav class="nav">
	<ul>
		<li><a class="" href="/">Home</a></li>
		<li><a class="nav-active" href="/articles/">Articles</a></li>
		<li><a class="" href="/about/">About</a></li>
		<li><a class="" href="/signup/">Newsletter</a></li>
	</ul>
</nav>
	  <main class="mainContent">
			<h1 class="article-heading">The disadvantages of Javascript polyfills</h1>
			<!-- <div class="meta">
	<time class="meta-date" date-time="2015-06-22">22 June 2015</time> <span class="meta-divider">&#183;</span>
	<span class="meta-readingTime" title="Estimated read time">
	  

	  
	    4 minute read
	  
	</span>
</div> -->
	      <p>A polyfill, also known as a shim, is a user-defined implementation of an API that some browsers provide natively, normalising browser differences.</p>

<p>As a proponent of <a href="/articles/developing-templates-using-an-outside-in-approach">outside-in development</a>, I see the lure of trying to develop as if all browsers are the same. The problem is that <a href="/articles/browsers-are-different-but-so-what/">browsers are not the same</a>. Polyfills are problematic because:</p>

<h2 id="they-augment-host-objects">1. They augment host objects</h2>

<p>Polyfills augment host and native objects. Experts such as Richard Cornford, David Mark, Thomas Lahn and Kangax have told us this is a bad idea. The latter of which published two articles on the subject:</p>

<ul>
  <li><a href="http://perfectionkills.com/whats-wrong-with-extending-the-dom/">What’s wrong with extending the DOM?</a></li>
  <li><a href="http://perfectionkills.com/extending-native-builtins/">Extending native built-ins</a></li>
</ul>

<p>Here’s a choice snippet:</p>

<blockquote>
  <p>“DOM extension seemed so temptingly useful […]. But what hides behind this seemingly innocuous practice is a huge load of trouble. […] the downsides of this approach far outweigh any benefits.”</p>
</blockquote>

<!--

## 2. Feature detection is not enough

As Peter Michaux shows us in [Feature Detection: State of the art browser scripting](http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting), the mere presence of an API is not always enough to determine its reliablity. This is where feature *testing* comes in.

Polyfills tend to just detect the presence of an API. They don't iron out the bugs or inconsistencies found in different browsers. Even if they did, they would have to override the original, whereby the override may contain a reference to it. This is dangerous and unnecessary. Instead, use facades, which we'll discuss shortly.



## 2. They intertwine browser and application logic

As Nicholas Zakas says in [Scalable JavaScript Application Architecture](https://www.youtube.com/watch?v=vXjVFPosQHw), it is important to decouple application and browser logic. He says:

> &ldquo;Application logic should be written one way for all browsers in order to keep the code maintainable. If you’re using native APIs in your application logic, you can’t help but know what browser is being used because you need to account for browser differences. That means your application logic will always need to be updated as new browsers and new browser versions are released. **That’s a recipe for disaster**&rdquo;.

-->

<h2 id="the-full-api-is-rarely-needed">2. The full API is rarely needed</h2>

<p>We may not need the full API to solve the problem. We may not even be <em>able</em> to implement a polyfill because there’s just no way to do so. This is why context is important.</p>

<p>We should first look to understand the problem precisely. And then solve <em>that</em> problem only. We rarely need <em>all</em> of an API, which I’ll demonstrate in a moment. With polyfills it’s all or nothing.</p>

<h2 id="they-come-with-caveats">3. They come with caveats</h2>

<p>It takes little effort to find problematic polyfills. Take the <a href="https://github.com/es-shims/es5-shim">ES5 Shim</a> documentation. In describing the <code>Object.create</code> polyfill it states:</p>

<blockquote>
  <p>“For the case of simply “begetting” an object that inherits prototypically from another, this <strong>should</strong> work fine across legacy engines.”</p>
</blockquote>

<p>The word <em>should</em> doesn’t instill confidence. We should, of course, build atop of reliable foundations—we are only as good as our lowest level functions. It continues:</p>

<blockquote>
  <p>“The second argument is passed to Object.defineProperties which will <strong>probably fail either silently or with extreme prejudice</strong>.”</p>
</blockquote>

<p>We shouldn’t expect our team to rely on code like this, much less our users. Any code we write around this is just ‘polishing a turd’.</p>

<h2 id="what-should-we-do-instead">What should we do instead?</h2>

<p>A facade or wrapper, is a design pattern that simplifies an interface around something more complex. This lets us abstract away the differing browser implementations and bugs. And with the added bonus of being able to simplify the method signature.</p>

<p>Inside the wrapper there’s nothing to stop us using bits of an API, and feature testing various implementations and acting accordingly, like Peter Michaux shows us in <a href="http://peter.michaux.ca/articles/cross-browser-widgets">Cross browser Widgets</a>.</p>

<p>Cloning an object is pertinent to this article because <code>Object.create</code> solves this problem. If we want to support <em>modern</em> browsers only—that is those that provide <code>Object.create</code>—then an implementation might look like this:</p>

<pre><code>var lib = {};
if(Object.create) {
  lib.cloneObject = function(obj) {
    return Object.create(obj);
  };
}
</code></pre>

<p>As this implementation only uses a small part of the entire API, the exposed method signature has just one argument, solving the precise problem and no more. But what about browsers lacking <code>Object.create</code>?</p>

<p>If we want to degrade gracefully, we don’t have to do anything (hello Progressive enhancement!). If we want to support other browsers add a second fork:</p>

<pre><code>// Code credited to David Mark. Thanks.
var lib = {};
if(Object.create) {
  lib.cloneObject = function(obj) {
    return Object.create(obj);
  };
} else {
  lib.cloneObject = (function() {
    var Fn = function() {};
      return function(obj) {
        Fn.prototype = obj;
        return new Fn();
    };
  })();
}
</code></pre>

<p>The problem got a bit more challenging but the implementation is still lean and the method signature holds up. But, we didn’t need to worry about recreating <code>Object.create</code> in its entirety.</p>

<p>But if we did need the full API, we could make two changes. First, change the name of the function to something more appropriate. Second, expand the method signature to allow for property descriptors like this:</p>

<pre><code>var lib = {};
if(Object.create) {
  lib.createObject = function(obj, props) {
    return Object.create(obj, props);
  };
}
</code></pre>

<p>What about browsers lacking <code>Object.create</code>? Same as before. Either degrade gracefully or add another fork. This is progressive enhancement.</p>

<h2 id="summary">Summary</h2>

<p>At best, polyfills are hard to implement and complicate matters by intertwining browser and application logic. This complexity is costly.</p>

<p>At worst, polyfills have caveats and gaps that cause pain for the developer and broken experiences for users.</p>

<p>Instead, use wrappers, which enable us to build reliable, progressively enhanced and therefore inclusive experiences.</p>

<!--

* ADDED IMPLEMENTATION Just because an API is implemented in a browser doesn't mean it's trustworthy. Sometimes, the spec is simply misunderstood and implemented differently across browser vendors. Adding a polyfill to the mix just adds complexity in the form of another user-defined implementation.

* CONSISTENCY Then there is the question of consistency. Do you want to use some polyfills and some facades. Probably not. Just use a consistent abstraction, a facade.

-->

	  </main>
		<div class="signUpHero">
	<p class="signUpHero-description">I write articles like this and share them with my private mailing list. No spam and definitely no popups. Just one article a month, straight to your inbox. Sign up below:</p>
</div>

<div class="testForm">
	<form action="//adamsilver.us9.list-manage.com/subscribe/post?u=b8fb04f39bf86109693e00ba5&amp;id=441c045a36" method="post">
		<input type="hidden" name="b_b8fb04f39bf86109693e00ba5_441c045a36" value="">
		<input type="hidden" name="SITE" value="https://adamsilver.io">
		<input type="hidden" name="LOCATION" value="/articles/the-disadvantages-of-javascript-polyfills/">
		<label for="mce-EMAIL" class="testForm-label">Your email address</label>
		<input type="email" name="EMAIL" id="mce-EMAIL" class="testForm-email" required><input class="testForm-button" type="submit" value="Join 1,000+ others" name="subscribe">
	</form>
</div>
	</body>
</html>